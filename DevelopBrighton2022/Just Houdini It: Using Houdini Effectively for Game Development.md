Speaker: [Sophie van den Boomen, PlayStation](https://www.linkedin.com/in/sophieboomen/)

# Overview
- Houdini has quickly become the shiny new tool in game development with studios ranging from indie to AAA keen to benefit from the prospect of generating an immense amount of content in shorter time periods. 
- The internet is filled with countless examples of exciting projects showing off the end results, but it can be hard for non-Houdini users to understand the possibilities and limitations of Houdini tools. 
- Having a better overview of this will be helpful in understanding where Houdini can improve workflows for your team while avoiding common pitfalls which often result in painful and costly work farther down the development pipeline. 
- Where are the best places to use Houdini in game projects
- Common misconceptions about Houdini & consequences of how this leads to problems

## Possibilities of Houdini for procedural generation & as a pipeline tool
- Placement & Scatter
  - Foliage
  - Pick-ups 
- Asset generation
  - Rocks
  - Pipes
  - Buildings 
- Terrain
  - World creation
  - Masks
  - Materials 
- Curve Tools
  - Placement
  - Generation 
- Pipelines
  - Automating LODs
  - Batch Exporting 
  - Culling assets
  - [PDG](https://www.sidefx.com/products/pdg/)
- VFX
  - Destruction
  - Water 
- And more...

## Common Misconceptions
- Houdini is for Realtimme Generation
- "Just Houdini it" for everything: tunnel vision
- Magic performance: Houdini = Good Performance
- Ambitious but open-ended ideas: no concept / idea needed
- "Quickly" make it: don't need a plan
- No standards: Houdini users are all the same

### Consequences of Misconceptions
- Difficult to plan
- Wasted time: tool / feature not being used
- Lack of coherence: no standards
- Inorganic tools: hard to work with
- Unsatisfying output: all sorts of ways

### Requirements
- Clear Goal: problem, input & output
- Testing: user feedback
- Level of Control: user, parameters
- Visual Guideline: sketch, concept, example

## Example: Procedurally-generated trees
1. Problem definition: Effectively communicate about potential tool requests, goals & scope
2. Research: Investigate pain points, User analysis table: User (Artist / Technical Artist / Programmer), Expressiveness, Learning Curve, Responsiveness (Low - High)
3. Input / Output: artist's asset (leave texture) + automatically placed leaves along branches  
4. Devloping
5. Testing

## What could go wrong?
- Open-ended 
- Planning
- Feature creep
- No feedback

## Tips
- Standards / guidelines
  - Naming
  - Versioning
  - Documenting: Node Color Conventions, User Guides, To-do lists, etc 
- Tool Breakdown
  - Small reusable tools
  - Collaboration 
- Tool Reviews
  - User & tech review
  - When?
- Research time
  - Importance of learning & development
